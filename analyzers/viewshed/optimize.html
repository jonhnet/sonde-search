<!DOCTYPE html>
<html>
<head>
    <title>Coverage Optimization - Sonde Receiver Placement</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
    <link rel="stylesheet" href="static/sidebar.css" />
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: #f5f5f5;
            padding: 0;
            margin: 0;
            overflow: hidden;
        }

        .container {
            max-width: 100%;
            height: 100vh;
            margin: 0;
            display: flex;
            flex-direction: row;
        }

        .sidebar {
            width: 400px;
            background: white;
            box-shadow: 2px 0 4px rgba(0,0,0,0.1);
            padding: 30px;
            overflow-y: auto;
            z-index: 1000;
        }

        .map-container {
            flex: 1;
            position: relative;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 28px;
        }

        .subtitle {
            color: #666;
            margin-bottom: 20px;
            font-size: 14px;
        }

        .section {
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 1px solid #e0e0e0;
        }

        .section:last-child {
            border-bottom: none;
        }

        .section-title {
            font-weight: 600;
            color: #333;
            margin-bottom: 15px;
            font-size: 16px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            margin-bottom: 15px;
        }

        label {
            font-weight: 600;
            margin-bottom: 5px;
            color: #333;
            font-size: 14px;
        }

        .label-help {
            font-weight: normal;
            color: #666;
            font-size: 12px;
            margin-top: 2px;
        }

        input, select {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        input:focus, select:focus {
            outline: none;
            border-color: #4CAF50;
        }

        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 4px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.3s;
            width: 100%;
        }

        button:hover {
            background: #45a049;
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .button-secondary {
            background: #2196F3;
            margin-bottom: 10px;
        }

        .button-secondary:hover {
            background: #1976D2;
        }

        #status {
            margin-top: 20px;
            padding: 15px;
            border-radius: 4px;
            display: none;
        }

        #status.info {
            background: #e3f2fd;
            border: 1px solid #2196F3;
            color: #1976D2;
            display: block;
        }

        #status.success {
            background: #e8f5e9;
            border: 1px solid #4CAF50;
            color: #2e7d32;
            display: block;
        }

        #status.error {
            background: #ffebee;
            border: 1px solid #f44336;
            color: #c62828;
            display: block;
        }

        #map {
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        .leaflet-container {
            height: 100%;
            width: 100%;
        }

        #results-panel {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
        }

        #results-panel.hidden {
            display: none;
        }

        .result-stats {
            background: #f9f9f9;
            padding: 15px;
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .stat-label {
            font-size: 14px;
            color: #666;
        }

        .stat-value {
            font-size: 18px;
            font-weight: 700;
            color: #4CAF50;
        }

        .instructions {
            background: #fff3cd;
            border: 1px solid #ffc107;
            padding: 12px;
            border-radius: 4px;
            font-size: 13px;
            color: #856404;
            margin-bottom: 15px;
        }

        .back-link {
            display: inline-block;
            color: #2196F3;
            text-decoration: none;
            margin-bottom: 20px;
            font-size: 14px;
        }

        .back-link:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <a href="./" class="back-link">← Back to Viewshed Analysis</a>

            <h1>Coverage Optimization</h1>
            <p class="subtitle">Find optimal receiver locations for target area coverage</p>

            <div class="section">
                <div class="section-title">1. Define Areas</div>
                <div class="instructions">
                    Click the rectangle tool (<span style="color: #4CAF50;">■</span>) in the map toolbar to draw:
                    <br>• <strong>Green rectangle</strong> = Target area to cover
                    <br>• <strong>Blue rectangle</strong> = Search area for receivers
                </div>
                <button id="clear-rectangles" class="button-secondary">Clear Rectangles</button>
            </div>

            <div class="section">
                <div class="section-title">2. Configure Parameters</div>

                <div class="form-group">
                    <label>
                        Antenna Height (meters AGL)
                        <span class="label-help">Height of receiver antenna above ground</span>
                    </label>
                    <input type="number" id="height" value="10" min="1" max="100" step="1">
                </div>

                <div class="form-group">
                    <label>
                        Target Grid Size
                        <span class="label-help">Points to test visibility to (NxN grid)</span>
                    </label>
                    <input type="number" id="target-grid" value="20" min="5" max="50" step="1">
                </div>

                <div class="form-group">
                    <label>
                        Search Grid Size
                        <span class="label-help">Candidate receiver locations (NxN grid)</span>
                    </label>
                    <input type="number" id="search-grid" value="10" min="5" max="30" step="1">
                </div>

                <div class="form-group">
                    <label>
                        Top K Candidates
                        <span class="label-help">How many best locations to hill-climb from</span>
                    </label>
                    <input type="number" id="top-k" value="5" min="1" max="10" step="1">
                </div>

                <div class="form-group">
                    <label>
                        Hill Climb Steps
                        <span class="label-help">Optimization iterations per candidate</span>
                    </label>
                    <input type="number" id="hill-climb-steps" value="10" min="5" max="50" step="1">
                </div>

                <div class="form-group">
                    <label>DEM Product</label>
                    <select id="dem-product">
                        <option value="SRTM3" selected>SRTM3 (90m, global)</option>
                        <option value="SRTM_BEST">SRTM Best (adaptive)</option>
                    </select>
                </div>
            </div>

            <div class="section">
                <div class="section-title">3. Run Optimization</div>
                <button id="optimize-btn">Find Optimal Location</button>
            </div>

            <div id="status"></div>

            <div id="results-panel" class="hidden">
                <div class="section-title">Results</div>
                <div class="result-stats">
                    <div class="stat-item">
                        <span class="stat-label">Best Location:</span>
                        <span class="stat-value" id="best-location">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Coverage:</span>
                        <span class="stat-value" id="coverage-pct">-</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="map-container">
            <button class="toggle-sidebar" id="toggle-sidebar" onclick="toggleSidebar()">☰</button>
            <div id="map"></div>
        </div>
    </div>

    <script src="static/sidebar.js"></script>
    <script>
        // Initialize map
        const map = L.map('map', {
            center: [47.6062, -122.3321],
            zoom: 8,
            preferCanvas: true
        });

        // Add basemap
        L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
            attribution: 'Map data: © OpenStreetMap contributors, SRTM | Map style: © OpenTopoMap',
            maxZoom: 17
        }).addTo(map);

        // State
        let targetRectangle = null;
        let searchRectangle = null;
        let currentJobId = null;
        let pollInterval = null;
        let resultsLayer = null;

        // Create feature groups for drawn items
        const drawnItems = new L.FeatureGroup();
        map.addLayer(drawnItems);

        // Add drawing controls
        const drawControl = new L.Control.Draw({
            draw: {
                rectangle: {
                    shapeOptions: {
                        color: '#4CAF50',
                        weight: 2
                    }
                },
                polygon: false,
                circle: false,
                marker: false,
                polyline: false,
                circlemarker: false
            },
            edit: {
                featureGroup: drawnItems,
                remove: true
            }
        });
        map.addControl(drawControl);

        // Handle rectangle drawing
        map.on(L.Draw.Event.CREATED, function(event) {
            const layer = event.layer;
            const bounds = layer.getBounds();

            // Determine if this is target or search based on what's missing
            if (!targetRectangle) {
                // First rectangle is target (green)
                layer.setStyle({ color: '#4CAF50', fillColor: '#4CAF50', fillOpacity: 0.2 });
                targetRectangle = bounds;
                drawnItems.addLayer(layer);
                layer._isTarget = true;
                showStatus('Target area defined. Now draw search area (where receivers can be placed).', 'info');
            } else if (!searchRectangle) {
                // Second rectangle is search (blue)
                layer.setStyle({ color: '#2196F3', fillColor: '#2196F3', fillOpacity: 0.2 });
                searchRectangle = bounds;
                drawnItems.addLayer(layer);
                layer._isSearch = true;
                showStatus('Both areas defined. Ready to optimize!', 'success');
            } else {
                showStatus('Both rectangles already drawn. Clear them first to redraw.', 'error');
            }
        });

        // Handle rectangle deletion
        map.on(L.Draw.Event.DELETED, function(event) {
            const layers = event.layers;
            layers.eachLayer(function(layer) {
                if (layer._isTarget) {
                    targetRectangle = null;
                }
                if (layer._isSearch) {
                    searchRectangle = null;
                }
            });
            showStatus('Rectangle(s) removed.', 'info');
        });

        // Clear rectangles button
        document.getElementById('clear-rectangles').addEventListener('click', function() {
            drawnItems.clearLayers();
            targetRectangle = null;
            searchRectangle = null;
            showStatus('All rectangles cleared.', 'info');
        });

        // Optimize button
        document.getElementById('optimize-btn').addEventListener('click', async function() {
            if (!targetRectangle || !searchRectangle) {
                showStatus('Please draw both target and search rectangles first.', 'error');
                return;
            }

            const params = {
                target_bounds: {
                    min_lat: targetRectangle.getSouth(),
                    max_lat: targetRectangle.getNorth(),
                    min_lon: targetRectangle.getWest(),
                    max_lon: targetRectangle.getEast()
                },
                search_bounds: {
                    min_lat: searchRectangle.getSouth(),
                    max_lat: searchRectangle.getNorth(),
                    min_lon: searchRectangle.getWest(),
                    max_lon: searchRectangle.getEast()
                },
                height: parseFloat(document.getElementById('height').value),
                target_grid_size: parseInt(document.getElementById('target-grid').value),
                search_grid_size: parseInt(document.getElementById('search-grid').value),
                top_k: parseInt(document.getElementById('top-k').value),
                hill_climb_steps: parseInt(document.getElementById('hill-climb-steps').value),
                dem_product: document.getElementById('dem-product').value
            };

            try {
                document.getElementById('optimize-btn').disabled = true;
                showStatus('Starting optimization...', 'info');

                const response = await fetch('optimize', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(params)
                });

                const data = await response.json();

                if (response.ok) {
                    currentJobId = data.job_id;
                    showStatus('Optimization running... This may take several minutes.', 'info');
                    startPolling();
                } else {
                    showStatus(`Error: ${data.error}`, 'error');
                    document.getElementById('optimize-btn').disabled = false;
                }
            } catch (error) {
                showStatus(`Error: ${error.message}`, 'error');
                document.getElementById('optimize-btn').disabled = false;
            }
        });

        // Poll for job status
        function startPolling() {
            if (pollInterval) clearInterval(pollInterval);

            pollInterval = setInterval(async () => {
                try {
                    const response = await fetch(`status/${currentJobId}`);
                    const job = await response.json();

                    if (job.status === 'running') {
                        // Update progress if available
                        if (job.progress_total && job.progress_completed !== undefined) {
                            const pct = Math.round((job.progress_completed / job.progress_total) * 100);
                            const message = job.progress_message || 'Processing...';
                            showStatus(`${message} (${pct}%)`, 'info');
                        }
                    } else if (job.status === 'completed') {
                        clearInterval(pollInterval);
                        displayResults(job);
                        showStatus('Optimization complete!', 'success');
                        document.getElementById('optimize-btn').disabled = false;
                    } else if (job.status === 'failed') {
                        clearInterval(pollInterval);
                        showStatus(`Optimization failed: ${job.error}`, 'error');
                        document.getElementById('optimize-btn').disabled = false;
                    }
                } catch (error) {
                    clearInterval(pollInterval);
                    showStatus(`Error polling status: ${error.message}`, 'error');
                    document.getElementById('optimize-btn').disabled = false;
                }
            }, 2000);  // Poll every 2 seconds
        }

        // Display results
        function displayResults(job) {
            const [lat, lon] = job.best_location;
            const coverage = job.best_coverage_pct;

            // Update stats
            document.getElementById('best-location').textContent = `${lat.toFixed(4)}, ${lon.toFixed(4)}`;
            document.getElementById('coverage-pct').textContent = `${coverage.toFixed(1)}%`;
            document.getElementById('results-panel').classList.remove('hidden');

            // Clear previous results
            if (resultsLayer) {
                map.removeLayer(resultsLayer);
            }

            // Create new layer group for results
            resultsLayer = L.layerGroup();

            // Add best location marker
            const marker = L.marker([lat, lon], {
                icon: L.divIcon({
                    className: 'best-location-marker',
                    html: '<div style="background: #f44336; width: 20px; height: 20px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"></div>',
                    iconSize: [20, 20],
                    iconAnchor: [10, 10]
                })
            }).bindPopup(`<b>Best Location</b><br>Coverage: ${coverage.toFixed(1)}%`);
            resultsLayer.addLayer(marker);

            // Add heatmap of all candidates
            if (job.all_candidates && job.all_candidates.length > 0) {
                // Find min/max coverage for color scaling
                const coverages = job.all_candidates.map(c => c[2]);
                const minCov = Math.min(...coverages);
                const maxCov = Math.max(...coverages);

                job.all_candidates.forEach(([candLat, candLon, candCov]) => {
                    // Color from red (low) to green (high)
                    const normalized = (candCov - minCov) / (maxCov - minCov || 1);
                    const hue = normalized * 120;  // 0 (red) to 120 (green)
                    const color = `hsl(${hue}, 70%, 50%)`;

                    L.circleMarker([candLat, candLon], {
                        radius: 3,
                        fillColor: color,
                        color: color,
                        weight: 1,
                        opacity: 0.6,
                        fillOpacity: 0.4
                    }).bindPopup(`Coverage: ${candCov.toFixed(1)}%`).addTo(resultsLayer);
                });
            }

            resultsLayer.addTo(map);

            // Zoom to best location
            map.setView([lat, lon], 12);
        }

        // Status message helper
        function showStatus(message, type) {
            const statusDiv = document.getElementById('status');
            statusDiv.textContent = message;
            statusDiv.className = type;
        }

        // Restore previous state from localStorage
        const savedLat = localStorage.getItem('lastOptimizeLat');
        const savedLon = localStorage.getItem('lastOptimizeLon');
        const savedZoom = localStorage.getItem('lastOptimizeZoom');
        if (savedLat && savedLon && savedZoom) {
            map.setView([parseFloat(savedLat), parseFloat(savedLon)], parseInt(savedZoom));
        }

        // Save map position on move
        map.on('moveend', function() {
            const center = map.getCenter();
            localStorage.setItem('lastOptimizeLat', center.lat);
            localStorage.setItem('lastOptimizeLon', center.lng);
            localStorage.setItem('lastOptimizeZoom', map.getZoom());
        });
    </script>
</body>
</html>
